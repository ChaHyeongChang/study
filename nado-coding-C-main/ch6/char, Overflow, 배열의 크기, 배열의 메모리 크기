/*
✅ char는 문자형이면서 정수형이다!
	-char는 문자 데이터를 저장하는 데 주로 사용됨.
		ex)'A', 'B', '1', '@' 같은 문자 저장 가능
			-내부적으로는 문자의 아스키코드 값(정수) 가 저장됨.
			char x = 100;  // 정수 100 저장 (문자로 보면 'd')
			printf("%c %d\n", x, x);  // 출력: d 100


	-하지만 char는 실제로 정수형 타입이다!
		-크기는 1바이트 (8비트)
		-문자뿐만 아니라 숫자(정수)도 저장 가능하고, 문자를 숫자로 연산할 수도 있음.
			char c = 'A' + 1;  // 'A'(65) + 1 = 66 ('B')
			printf("%c\n", c);  // 출력: B

*/

#include <stdio.h>

int main() {
    char arr[] = {1, 2, 3, 4, 5}; //char형은 1byte 크기의 정수형이므로 숫자를 넣을 수 있다. 따라서 char a = 10; 도 가능(char의 범위인 -128 ~ 127 안에 값이 있다면)
    int i;

    // 정수값으로 출력
    printf("정수값 출력: ");
    for (i = 0; i < 5; i++) {
        printf("%d ", arr[i]);  // 정수값 출력
    }

    printf("\n문자 출력: ");
    for (i = 0; i < 5; i++) {
        printf("%c ", arr[i]);  // ASCII 문자 출력
    }

    return 0;
}

/*
✅ 숫자는 1바이트인가?
		-char 타입 숫자(예: char a = 1;) → 1바이트
		-int 타입 숫자(예: int b = 1;) → 4바이트
		-long long 같은 큰 숫자 → 8바이트

	즉, 데이터 타입에 따라 숫자가 차지하는 크기가 다름!
*/


/*
✅ 배열의 크기(요소의 개수)와, 배열의 메모리 크기, 문자열의 크기
		-int arr[] = {1, 2, 3, 4, 5}; --> 배열의 크기(요소의 개수) = 5
		-int arr[] = {1, 2, 3, 4, 5}; --> 배열의 메모리 크기 ==> 배열의 크기 x 각 요소의 크기 ----> 배열의 크기는 5, int 타입의 크기는 4byte 이므로 배열이 차지하는 메모리 크기는 5 x 4 = 20byte

		-char arr[] = {1, 2, 3, 4, 5}; → 5바이트 (널문자 없음)
			-->배열의 크기 = 5
			-->배열의 메모리 크기 => 5 x 1 = 5byte

		-char str[] = "Hello"; → 6바이트 (널문자 포함됨)
			-->문자열의 길이 = 5

	널문자는 문자열(" " 사용)에서만 자동 추가됨!
*/

/*
🔥 결론 🔥
	-char는 최대(unsigned char) 255, 또는 char(-128~127)까지만 저장 가능.
	-char는 단순히 문자(Character)만 저장하는 타입이 아니라, 1바이트 크기의 정수형, 따라서 숫자도 저장할 수 있고 문자도 저장할 수 있음
	-문자를 저장하면 실제로는 ASCII 코드값이 저장됨.
*/


/*
	ex) char arr[] = {100, 300, 4400};

	🚨 char arr[] = {100, 300, 4400};에서 문제 발생(출력은 가능하지만 overflow로 인해 다른 값 출력됨!)		
		-char는 1바이트(8비트) 이므로 최대 저장 가능한 값이 255 (unsigned char 기준).
		-하지만 100, 300, 4400은 범위를 초과하는 값이므로, 오버플로우(Overflow)가 발생하여 잘못된 값이 저장됨.

	✅ 300과 4400을 1byte로 변환하는 방법(🔥오버플로우(Overflow)가 발행해 값이 잘림🔥) 
			-300은 1바이트(char) 크기를 초과하므로 8비트(1바이트)만 남기고 앞부분이 잘림.
			-300(10진수) → 100101100(2진수) → 00101100(8비트) → 44(10진수)
			-🎯따라서 char a = 300; 하면 a = 44가 됨! 🎯


	✅ 프로그램이 값은 다르지만 실행은 되는 이유
			-C 언어에서 더 큰 정수를 작은 타입(char)에 저장할 때 자동으로 오버플로우 처리를 하기 때문에 컴파일 에러는 발생하지 않지만, 값이 변형됨!
			-300이 char(1바이트)에 저장될 때 44로 변형됨.
			-정확한 값을 저장하려면 더 큰 자료형(int, short)을 사용해야 함! 🚀
*/


/*
✅ 줄바꿈 대신에 printf("%c", 10);
		-10은 ASCII 코드에서 줄바꿈(New Line, \n) 문자에 해당함.
		-따라서 printf("%c", 10); 은 printf("\n"); 과 같은 동작을 합니다.

	ex)
		#include <stdio.h>

			int main() {
    			printf("Hello");
 				printf("%c", 10);  // ASCII 10 → 줄바꿈
    			printf("World");

    			return 0;
			}
✅ 줄바꿈 대신에 puts("");
	puts("");가 줄바꿈을 하는 이유
		-puts() 함수 자체가 문자열을 출력한 후후 자동으로 줄바꿈(\n)을 추가
		-puts("")는 빈 문자열("")을 출력하므로, 화면에는 아무것도 출력되지 않고 자동 줄바꿈이 발생
*/








