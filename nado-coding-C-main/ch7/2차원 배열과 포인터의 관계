
//p219 a4 [8]필기 (2차원 배열과 포인터의 관계1)

//2차원 배열은 포인터 타입이 열에 따라서 달라진다!!
//포인터를 움직일 때 !행단위!로 움직임

///요약(중요)
/*
int arr[2][3];

int (*p)[3];

p = &arr;

// p == arr[0] == *arr

// *arr은 *(arr + 0)이고 0번재 행 자체를 의미, 따라서 arr[0]과 동일

// *(arr + 1)은 1번째 행 자체를 의미, 따라서 arr[1]과 동일 
// arr + 1은 1번째 행의 시작주소
// arr[1]은 1번째 행을 의미하는 배열 이름 -> 배열의 첫 번째 주소로 반환됨

//따라서 1번째 행의 첫 번째 값을 참조 하고 싶으면 *(*(arr + 1) + 0), arr[1][0], (*(arr + 1))[0], *(arr[1] + 0) 이렇게 쓰는 거임

*/

#include <stdio.h>

int main(void){

    //int p; --> 정수를 저장
    //int *p; --> p는 int형의 주소를 저장하는 포인터 4byte의 주소를 저장 (p의 크기는 항상 8byte : 포인터 이므로)
    //int *p[2] --> 포인터 배열

    //int (*p)[2] --> p는 int형의 데이터를 2개씩 점프하는 포인터 (8byte씩 점프)

    int a[3][2]; //열에 따라서 몇byte가 증가하는지 결정됨!
    //a(배열의 이름)은 포인터 (시작 주소를 가리킴)
    //+1 할때마다 8byte 씩 증가(4byte 짜리 메모리를 2개씩 점프하므로)

    int (*p)[2]; //( )를 안쓰면 포인터 배열과 구분할 수 없음!! 따라서 2차원 배열의 포인터 타입을 선언할때는 ( )사용
                //[ ]안의 값은 int형의 변수를 몇개씩 점프하는지 결정


    int b[4][3]; //열에 따라서 몇byte가 증가하는지 결정됨!
    //b(배열의 이름)은 포인터 (시작 주소를 가리킴)
    //+1 할때마다 12byte 씩 증가(4byte 자리 메모리를 3개씩 점프하므로)

    int (*p2)[3]; // b는 시작 주소를 가리키므로 p2 = b
                //( )를 안쓰면 포인터 배열과 구분할 수 없음!! 따라서 2차원 배열의 포인터 타입을 선언할때는 ( )사용
                //[ ]안의 값은 int형의 변수를 몇개씩 점프하는지 결정

    
    printf("%d\n", sizeof(*p)); // 8 : sizeof(*p) == sizeof(int[2]) int[2]의 크기는 2 x sizeof(int) = 2 x 4 = 8
    printf("%d\n", sizeof(a)); // 24 : 배열의 총 원소 수 3 x 2 = 6, sizeof(int) = 4, 6 x 4 = 24byte
    printf("%d\n\n", sizeof(p)); // 8 : 포인터의 크기는 항상 8byte 이므로(몇  byte 점프하는것과 크기는 별개임)

    printf("%d\n", sizeof(*p2)); // 12 : sizeof(*p2) == sizeof(int[3]) int[3]의 크기는 3 x sizeof(int) = 3 x 4 = 12
    printf("%d\n", sizeof(b)); // 48 : 따라서 4 x 12 = 48byte
                                // 배열의 총 원소 수 4 x 3 = 12
                                // sizeof(int) == 4
    printf("%d\n", sizeof(p2)); // 8 : 포인터의 크기는 항상 8byte 이므로(몇  byte 점프하는것과 크기는 별개임)
    //변수 p2는 int (*)[3]타입의 포인터, 즉 p2는 #int [3]를 가리키는 포인터# 이므로 sizeof(p2)는 일반적인 포인터의 크기와 동일!
    
    //#int [3]를 가리키는 포인터에 대한 설명#
    //b자체는 int[4][3]
    //b는 "4개의 int[3] 배열"이 모여있는 2차원 배열
    //b의 각 행(b[0], b[1], ...)은 각각 int [3]타입


    return 0;
}
/*
ex) double d[4][3]; double (*p)[3];
    char c[1000][1024]; char (*p)[1024];
    double arr[100][3]; double (*p)[3];

    //자료형과 열이 같다면 행에 상관없이 포인터 타입은 일치(ex : (*p)[3] )

*/



//p219 a4 [9]필기 (2차원 배열과 포인터의 관계2)

// a == a[0] // a연산 : 행단위, a[0]연산 : 열단위

//배열 이름의 연산은 행단위
//배열 이름의 행첨자의 연산은 열단위

#include <stdio.h>

int main(void){
    int a[3][2];

    // a == a[0] // a연산 : 행단위, a[0]연산 : 열단위

    // a -> 배열의 시작주소
    // a[0] -> 0행의 시작주소
    // a == a[0]
    // a[1] -> 1행의 시작주소
    // a[2] -> 2행의 시작주소

    /*
    //전부 a[0][0]의 방을 가리킴

    a[0][0] //인덱스는 역참조의 의미도 가진다!!(배열에서만 쓰는게 아니라)
    (*(a + 0))[0] //[0]은 열을 나타냄, (a의 0번째 방이 가리키는값)[0], [0] --> 열
    *(a[0] + 0) //a[0] -> 행을 인덱스로 표현, 행을 인덱스로 표현하고 +0이 가리키는 값
    *(*(a + 0) + 0)

    */

    int b[4][3];

    // b == b[0] // b연산 : 행단위, b[0]연산 : 열단위위

    // b -> 배열의 시작주소
    // b[0] -> 0행의 시작주소
    // b[1] -> 1행의 시작주소
    // b[2] -> 2행의 시작주소
    // b[3] -> 3행의 시작주소

    /*
    //전부 b[0][0]의 방을 가리킴

    b[0][0] //인덱스는 역참조의 의미도 가진다!!(배열에서만 쓰는게 아니라)
    (*(b + 0))[0] //[0]은 열을 나타냄, (ㅠㅠ의 0번째 방이 가리키는값)[0], [0] --> 열
    *(b[0] + 0) //b[0] -> 행을 인덱스로 표현, 행을 인덱스로 표현하고 +0이 가리키는 값
    *(*(b + 0) + 0)

    */

    return 0;
}

// 필기 아래쪽 그림설명
/*
1차원 배열 : 포인터 1개로 만들어진 자료형

2차원배열 : 1차원 배열이 여러개 있는 것, 1차원 배열을 하나 만드는데 포인터 1개씩 필요하다면 1차원 배열을 여러개 만드려면 포인터가 여러개 필요함!

int (*a)[3]; //✅배열의 이름은 이중포인터 타입이므로 행연산✅ 포인터의 포인터 -> 이중포인터(a[0]의 주소를 저장하는 포인터)(*이 1개인)
             //✅포인터가 주소를 가리키고 있을때는 포인터 타입이므로 열연산✅
*/
