p219, p219 a4용지 필기
//🔥배열의 이름은 포인터🔥, 배열의 이름만 쓰게되면 배열의 시작 주소를 나타내는 포인터
//배열이 포인터라는 것이 아님!! --> 배열의 이름이 포인터!
//배열에 인덱스를 붙이지 않고 배열의 이름 a만 딱 쓴다고 하면 &a[0](a 0번째의 주소)와 같음
//배열의 이름은 배열의 첫 번째 주소를 가리키는 포인터

//🔥배열은 결국은 포인터를 1씩 증가하면서 만들어지는 자료구조🔥
//✅배열에서 인덱스나 *(역참조)를 사용하면 원소값을 나타낼 수 있고 원소값을 나타내기위해서 인덱스나 *(역참조)가 필요한 이유는 배열의 이름이 포인터이기 때문임!✅
//따라서서 배열의 이름이 포인터이기 때문에 배열을 함수로 전달하는 방법을 배워야함
/*
#include <stdio.h>

int main(void){
    int a[5] = {1,2,3,4,5};
    int *p; //int형의 주소를 포인터로 선언
    p = a; //배열의 이름도 포인터이기 때문에 포인터의 배열의 이름(배열의 시작주소)를 가리키는 것이 가능
    //p는 a배열의 시작 주소를 가리키게됨
    
    return 0;
}
*/

//***포인터 연산***
/*
    포인터는 가리키는 역할을 하는데 포인터 변수의 중간 주소값을 가지는것은 아무 의미가 없기 때문에 가리키는 포인터의 크기만큼 증가하거나 감소함!!
    포인터가 int형이면 4byte 증가, char형이면 1byte 증가, double형이면 8byte 증가 
    -->포인터는 연산할 때 가리키는 데이터의 크기(int, char, double ...)만큼 증가하거나 감소함

    ex) int *p;를 100번지라고 하면 p+1 ? --> 104번지
        char *p;를 100번지라고 하면 p+1 ? --> 101번지
        double *p;를 100번지라고 하면 p+1 ? --> 108번지

    따라서
    *(a + 2) => 3, *(a + 4) => 5
    *(p + 1) => 2, *(p + 4) => 5

    *(a + 2) == a[2]
    *(a + 4) == a[4]

    배열이라는 자료구조는 포인터로 만들어짐
    --> a라는 포인터 하나로 1씩 증가하면서 만들어진 자료구조 : 일차원 배열
    ----> 배열의 인덱스가 0부터 시작하는 이유는 배열의 포인터에서 주소 증가를 하지 않았기 때문!!
    ==> a[0]은 (a + 0)이 가리키는 메모리 a[0] == *(a + 0), a[1]은 a + 1이 가리키는 메모리 a[1] == *(a + 1) .....

    지금까지는 역참조 할 때 *만 가능한줄 알았는데 사실 인덱스 연산자가 하는 일이 배열의 주소를 가리키는 값이었음!!!! --> a[1]을 쓰나 *(a + 1)을 쓰나 완벽하게 같은 의미
    --> 배열 : a라는 포인터 하나로 포인터를 1씩 증가하면서 만들어진 연속적인 자료 공간
    --> 따라서 인덱스와 *(역참조)의 다른점은 없음
*/ 

/*
#include <stdio.h>

int main(void){
    int a = 5;
    int *p = &a; //p는 a의 주소를 가리킴

    //두 식의 의미가 같음!!
    *p = 10;
    p[0] = 10;
    //인덱스 : 포인터가 가리키는 메모리인데 주소 증가를 몇 번 하느냐!! --> 배열이라도 인덱스를 나타내지 않으면 주소값을 가리키는 것임!
                                                                        //ex) a[1]은 2, (a + 1)은 &a[1] (의 첫번째 주소값), *(a + 1)은 2
    return 0;
}
*/



////////////////////// 배열과 포인터의 관계 실습 /////////////////////////

//2.1 배열명도 포인터다.
/*
#include <stdio.h>

int main(void){
    int a[5] = {1,2,3,4,5};

    printf("%d, %d \n", a[0], a[1]); // 1 2
    printf("%d, %d \n", &a[0], &a[1]); // a[0]의 첫번째 주소 a[1]의 첫번째 주소
    printf("%d \n", a); // a의 시작주소 == a[0]의 첫번째 주소

    return 0;
}
*/


// 2.2 -- 1차원 배열명의 포인터 타입
// 배열명도 포인터이므로 타입이 존재함. 배열명의 포인터 타입은 배열명이 가리키는 배열 요소의 자료형에 의해 결정됨
/*
#include <stdio.h>

int main(void){
    int a[3] = {1,2,3};
    int *ptr;

    ptr = a; //ptr은 a의 시작주소(&a[0])를 저장하는 포인터

    printf("%d, %d, %d \n", a[0], a[1], a[2]); // 1 2 3
    printf("%d, %d, %d \n", ptr[0], ptr[1], ptr[2]); // 1 2 3
    printf("%d, %d, %d \n", *(ptr + 0), *(ptr + 1), *(ptr + 2)); // 1 2 3 --> int형 이므로 +1 할때마다 4byte씩 증가
    printf("%d, %d, %d \n", *(a + 0), *(a + 1), *(a + 2)); // 1 2 3 --> int형 이므로 +1 할때마다 4byte씩 증가

    return 0;
}
*/

// 2.3 포인터 연산
// 포인터 연산이란 포인터 값을 증가 또는 감소시키는 연산을 말함. 포인터가 가리키는 대상상의 자료형에 따라서 증가 및 감소함
// ptr++;    ptr += 2;    --ptr;    ptr = p + 2;
/*
#include <stdio.h>

int main(void){
    char c = 'a';
    int i  = 3;
    double d = 3.14;

    char *cp = &c;
    int *ip = &i;
    double *dp = &d;

    printf("%d %d %d\n", cp, ip, dp); //각 변수의 시작 주소값을 출력
    cp++;   ip++;   dp++; // 포인터 증가
    printf("%d %d %d\n", cp, ip, dp); // 각 변수의 시작 주소값에서 대상의 자료형만큼 증가 char -> +1byte    int -> +4byte   double -> +8byte

    return 0;
}
*/
/*
#include <stdio.h>

int main(void){
    //배열이름은 배열의 시작주소만을 가리킬 수 있는 포인터 상수!! => 배열의 첫 번째 원소는 무조건 a[0]
    //배열이름 => 포인터 상수💡(변하지 않음, 따라서 변경이 불가능)
    //포인터   => 포인터 변수
    int *p, a[5] = {10,20,30,40,50};

    p = a; //p는 배열 a의 시작주소를 저장하는 포인터

    printf("1. %p\n", a); //a의 시작주소 == printf("1. %p\n", p); 그리고 주소를 출력할때는 %p사용!! -> int* 는 8바이트고 int는 4바이트라 데이터 솔실 될 수 있음
    printf("2. %d\n", *p); // 10
    printf("3. %d\n", *(p + 1)); // 20
    printf("4. %d\n", p[2]); // 30
    printf("5. %d\n\n", *(a + 2)); // 30

    p = p + 2; //p + 2 == &a[2], p가 &a[2]의 주소를 가리킴
    //a = a + 2; //error : 배열 이름은 상수기 때문에 변경이 불가능!

    p = a + 2; //배열 a의 시작 주소에 2를 더한 주소를 p에 저장 --> p = &a[2]
    //a = p + 2; //error : 배열 이름은 상수기 때문에 변경이 불가능!

    printf("6. %p\n", a); //a의 시작주소
    printf("7. %d\n", *p); // 30 : p가 &a[2]를 가리키므로
    printf("8. %d\n", *(p + 2)); // 50
    printf("9. %p\n", p - 1); //&a[1]의 주소, printf("9. %p\n", a + 1);
    printf("10. %d\n", a[2]); // 30
    printf("11. %d\n", p[2]); // 50
    printf("12. %d\n", p[-1]); // 20
    printf("13. %d\n", *p + 2); // 32 : *p의 값은 30 이고 +2를 하면 32이므로

    return 0;
}
*/

//포인터 연산자와  증감 연산자를 함께 사용하는 식은 빈번하게 쓰이고 이중에서 *ptr++이 가장 활용도가 높음

#include <stdio.h>

int main(void){
    int a[] = {10, 20, 30, 40, 50};
    int i, j = 10;
    int *ptr;

    ptr = a;
    for(i = 0; i < 5; i++){ //*ptr과 ptr++이 결합된 형태
        printf("%d ", *ptr++); //ptr++가 먼저 수행된 후 *가 적용됨 : *ptr++은 포인터를 먼저 증가시키고, ✅증가하기 전의 주소를 반환함.✅
    }                            // ptr++ 증가 하고 printf문이 실행될때는 증가하기 전 ptr의 주소를 반환 따라서 10 20 30 40 50 출력 
    puts("");

    
    //ex)
        //#include <stdio.h>

        //int main() {
        //    int arr[] = {10, 20, 30};
        //    int *ptr = arr;  // ptr이 arr[0]을 가리킴

        //    printf("Before: ptr = %p, *ptr = %d\n", ptr, *ptr); //Before: ptr = 0x600003e40, *ptr = 10 
        //    printf("Value: %d\n", *ptr++); //Value: 10  // *ptr을 먼저 평가한 후, ptr 증가 
        //    printf("After: ptr = %p, *ptr = %d\n", ptr, *ptr); //After: ptr = 0x600003e44(4바이트증가), *ptr = 20

        //    return 0;
        //}
    


    ptr = a;
    for(i = 0; i < 5; i++){ //++ptr과 *ptr이 결합된 형태
        printf("%d ", *++ptr); //++ptr가 먼저 수행된 후 *가 적용됨 : *++ptr은 포인터를 먼저 증가시키고, ✅증가된 주소를 반환함.✅
    }                       // ++ptr 증가 하고 printf문이 실행될때 증가된 ptr의 주소를 반환 따라서 20 30 40 50 0 출력 
    puts("");


    ptr = a;
    for(i = 0; i < 5; i++){
        printf("%d ", ++*ptr); // ++a[i]와 같은 형태 *ptr의 값인 10에 ++(*ptr)연산을 해서 11 12 13 14 15의 값이 나옴
    }
    puts("");


    ptr = a;
    for(i = 0; i < 5; i++){
        printf("%d ", (*ptr)++); // a[i]++과 같은 형태 위에서 *ptr의 값인 15에 (*ptr)++연산을 해서 15 16 17 18 19의 값이 나옴
    }
    puts("");

    return 0;
}



// 2.4 배열 이름과 포인터의 차이점
// 배열 이름은 배열 전체를 대표하는 상수포인터 이므로 증감연산을 수행할 수 없음!!

/*
#include <stdio.h>

int main(void){
    int *p, a[5] = {10, 20, 30, 40, 50};

    p = a;

    printf("%d\n", sizeof(p)); // 8 : p는 포인터 변수이므로 64비트 시스템에서 항상 8byte의 크기를 가짐 (포인터는 메모리 주소를 저장하므로 8byte)
    printf("%d\n", sizeof(a)); // 20 : a는 크기가 5인 배열이므로 5 * 4 = 20 (배열의 요소 개수 x 요소 크기)

    p++; // p = p + 1

//  a++; // a = a + 1 (컴파일 오류 : 배열 이름은 상수포인터이므로 값을 변경할 수 없음!)
    
    return 0;

}
*/



////// 1차원 배열을 함수의 인수로 전달하는 경우 --> 1차원 배열과 포인터의 관계를 알 수 있음 //////

//배열의 이름은 포인터이므로 배열을 전송할 때에는 무조건 포인터로 받는다!!

/*
#include <stdio.h>

void fun(int *p);

int main(void){

    int arr[5] = {5, 6, 7, 8, 9};

    fun(arr); // arr을 전달한다는건 배열을 넘기는 것이 아니라 배열의 시작주소를 전달하는 것! --> 함수의 매개변수를 포인터로 받음음

    return 0;
}

void fun(int *p){ //배열의 이름은 포인터이므로 배열을 전송할 때에는 무조건 포인터로 받는다!!
    for(int i = 0; i < 5; i++){
        printf("%d ", p[i]); 
        // *(p + 2) == p[2] 일치함
    }
}
*/
